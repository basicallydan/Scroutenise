var DirectionsRouteHelpers = {
  /*
  * Gets a list of points along the path by 
  */
  getPathAsLatLngArray: function (directionResult, maxDistanceBetweenPoints) {
    if (typeof maxDistanceBetweenPoints === 'undefined') { maxDistanceBetweenPoints = 0; }

    var myRoute = directionResult.routes[0].legs[0],
      totalDistance = myRoute.distance.value,
      path = [];

    for (var i = 0; i < myRoute.steps.length; i++) {

      // Do we need to split this step up?
      var start = myRoute.steps[i].start_location;
      var end = i + 1 < myRoute.steps.length ? myRoute.steps[i + 1].start_location : myRoute.steps[i].end_location;
      // var distanceBetweenStartAndEnd = google.maps.geometry.spherical.computeDistanceBetween(start, end);
      var stepDistanceInMetres = myRoute.steps[i].distance.value;

      // Push the starting point, to start with
      path.push(start);

      if (stepDistanceInMetres > maxDistanceBetweenPoints) {
        // Get a number of the points along the route based on their position along the path
        var numberOfSplits = Math.round(stepDistanceInMetres / maxDistanceBetweenPoints);
        var splitIncrement = myRoute.steps[i].path.length / numberOfSplits;

        for (var s = 1; s < myRoute.steps[i].path.length; s += splitIncrement) {
          var pathIndex = Math.round(s);

          if (pathIndex < myRoute.steps[i].path.length - 1 && pathIndex > 0) { path.push(myRoute.steps[i].path[pathIndex]); }
        }
      }
    }
    return path;
  }
}
// if (typeof(google.maps.LatLng.pointAtAngleWithRadius) === 'undefined') {
//   google.maps.LatLng.prototype.pointAtAngleWithRadius = function(angleInDegrees, radius)
//   {        
//     var angleInRads = angleInDegrees.toRad();

//     var lat = this.lat();
//     var lng = this.lng();
//     var cLat = (radius / 3963).toDeg();      //  using 3963 as earth's radius
//     var cLng = cLat / Math.cos(lat.toRad());

//     Cx = lng + (cLng * Math.cos(angleInRads));
//     Cy = lat + (cLat * Math.sin(angleInRads));

//     var val = (Cy - lat) / cLat;

//     var angleBack = Math.asin(val);

//     return new google.maps.LatLng(Cy,Cx);
//   }
// }


if (typeof(google.maps.LatLng.pointAtAngleWithRadius) === 'undefined') {
  google.maps.LatLng.prototype.pointAtAngleWithRadius = function(brng, radius) {
    var lat = this.lat();
    var lng = this.lng();

    var earthRadius = 6371000;

    radius = typeof(radius) == 'number' ? radius : typeof(radius) == 'string' && radius.trim() != '' ? +radius : NaN;

    radius = radius / earthRadius;

    brng = brng.toRad();

    var lat1 = lat.toRad(),
        lon1 = lng.toRad();

    var lat2 = Math.asin(Math.sin(lat1) * Math.cos(radius) + Math.cos(lat1) * Math.sin(radius) * Math.cos(brng));
    var lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(radius) * Math.cos(lat1), Math.cos(radius) - Math.sin(lat1) * Math.sin(lat2));
    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
  }
}

if (typeof(google.maps.LatLng.getLatLngBounds) === 'undefined')
{
  google.maps.LatLng.prototype.getLatLngBounds = function(radius)
  {
    var nePoint = this.pointAtAngleWithRadius(45, radius);
    var swPoint = this.pointAtAngleWithRadius(225, radius);

    var bounds = new google.maps.LatLngBounds(swPoint, nePoint);

    return bounds;
  }
}

if (typeof(google.maps.LatLngBounds.expandBy) === 'undefined')
{
  google.maps.LatLngBounds.prototype.expandBy = function(radius)
  {
    var nePoint = this.getNorthEast().pointAtAngleWithRadius(45, radius);
    var swPoint = this.getSouthWest().pointAtAngleWithRadius(225, radius);

    var bounds = new google.maps.LatLngBounds(swPoint, nePoint);

    return bounds;
  }
}
if (typeof(google.maps.Map.everyInfoWindow) === 'undefined')
  google.maps.Map.prototype.everyInfoWindow = [];

if (typeof(google.maps.Map.allMarkers) === 'undefined')
  google.maps.Map.prototype.allMarkers = [];

if (typeof(google.maps.Map.allCircles) === 'undefined')
  google.maps.Map.prototype.allCircles = [];

/*
* Marker Management
*/

if (typeof(google.maps.Map.addMarker) === 'undefined') {
  google.maps.Map.prototype.addMarker = function(marker) {
    marker.setMap(this);
    this.allMarkers.push(marker);
  };
}

if (typeof(google.maps.Map.clearMarkers) === 'undefined') {
  google.maps.Map.prototype.clearMarkers = function()
  {
    if (this.allMarkers) {
      for (var i = 0; i < this.allMarkers.length; i++) {
        this.allMarkers[i].setMap(null);
      }
    }
    this.allMarkers = [];
  };
}

/*
* Circle Management
*/

if (typeof(google.maps.Map.clearCircles) === 'undefined') {
  google.maps.Map.prototype.clearCircles = function()
  {
    if (this.allCircles) {
      for (var i = 0; i < this.allCircles.length; i++) {
        this.allCircles[i].setMap(null);
      }
    }
    this.allCircles = [];
  }
}

if (typeof(google.maps.Map.addCircle) === 'undefined') {
  google.maps.Map.prototype.addCircle = function(circle)
  {
    circle.setMap(this);
    this.allCircles.push(circle);
  }
}

/*
* Info Window Management
*/

if (typeof(google.maps.Map.addInfoWindow) === 'undefined') {
  google.maps.Map.prototype.addInfoWindow = function(infoWindow, marker) {

    var thisMap = this;

    google.maps.event.addListener(marker, 'click', function() {
      for(var i = 0; i < thisMap.everyInfoWindow.length; i++)
      {
        thisMap.everyInfoWindow[i].close();
      }

      infoWindow.open(thisMap, marker);
    });

    google.maps.event.addListener(this, 'click', function() {
      infoWindow.close();
    });

    this.everyInfoWindow.push(infoWindow);
  };
}
/** Converts numeric degrees to radians */
if (typeof(Number.prototype.toRad) === 'undefined') {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  }
}

/** Converts radians to numeric (signed) degrees */
if (typeof(Number.prototype.toDeg) === 'undefined') {
  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  }
}
var PlaceTypes = {
  capitalize: function (word, position){
    if(word.length == 2)
    {
      var arrayOfChars = word.split('');
      if(PlaceTypes.Vowels.indexOf(arrayOfChars[0]) == -1 && PlaceTypes.Vowels.indexOf(arrayOfChars[1]) == -1)
        return word.toUpperCase();
      else
        return word.toLowerCase();
    }

    if(PlaceTypes.WordsNotToCapitalize.indexOf(word) == -1 || position == 0)
    {
      var capitalizedWord = word.substring(0, 1).toUpperCase() + word.substring(1);
      return capitalizedWord;
    }
  },

  getPlaceTypesAsHuman: function () {
    var humanTypes = [];
    for(var i = 0; i < PlaceTypes.PlaceTypes.length; i++)
    {
      humanTypes.push(PlaceTypes.underscoredToHuman(PlaceTypes.PlaceTypes[i]));
    }

    for(var aliasIndex in PlaceTypes.Aliases) {
      
      humanTypes.push(PlaceTypes.underscoredToHuman(aliasIndex))
    }
    return humanTypes;
  },

  underscoredToHuman: function (word) {
    var individualWords = word.split('_');
    var finalWord = [];
    for(var w = 0; w < individualWords.length; w++)
    {
      finalWord.push(PlaceTypes.capitalize(individualWords[w], w));
    }
    return finalWord.join(' ');
  },

  getActualTypeIfAlias: function (type) {
    if(typeof(PlaceTypes.Aliases[type]) == 'undefined')
      return type;
    
    return PlaceTypes.Aliases[type];
  }
}

PlaceTypes.Vowels = [
  'a',
  'e',
  'i',
  'o',
  'u'
];

PlaceTypes.WordsNotToCapitalize = [
  'of',
  'the',
  'a',
  'an',
  'it'
];

PlaceTypes.Aliases = {
  "petrol_station" : "gas_station",
  "booze_station" : "liquor_store",
  "coffee_shop" : "cafe",
  "shopping_centre" : "shopping_mall",
  "bike_shop" : "bicycle_store"
};

PlaceTypes.PlaceTypes = [
  "accounting",
  "airport",
  "amusement_park",
  "aquarium",
  "art_gallery",
  "atm",
  "bakery",
  "bank",
  "bar",
  "beauty_salon",
  "bicycle_store",
  "book_store",
  "bowling_alley",
  "bus_station",
  "cafe",
  "campground",
  "car_dealer",
  "car_rental",
  "car_repair",
  "car_wash",
  "casino",
  "cemetery",
  "church",
  "city_hall",
  "clothing_store",
  "convenience_store",
  "courthouse",
  "dentist",
  "department_store",
  "doctor",
  "electrician",
  "electronics_store",
  "embassy",
  "establishment",
  "finance",
  "fire_station",
  "florist",
  "food",
  "funeral_home",
  "furniture_store",
  "gas_station",
  "general_contractor",
  "geocode",
  "grocery_or_supermarket",
  "gym",
  "hair_care",
  "hardware_store",
  "health",
  "hindu_temple",
  "home_goods_store",
  "hospital",
  "insurance_agency",
  "jewelry_store",
  "laundry",
  "lawyer",
  "library",
  "liquor_store",
  "local_government_office",
  "locksmith",
  "lodging",
  "meal_delivery",
  "meal_takeaway",
  "mosque",
  "movie_rental",
  "movie_theater",
  "moving_company",
  "museum",
  "night_club",
  "painter",
  "park",
  "parking",
  "pet_store",
  "pharmacy",
  "physiotherapist",
  "place_of_worship",
  "plumber",
  "police",
  "post_office",
  "real_estate_agency",
  "restaurant",
  "roofing_contractor",
  "rv_park",
  "school",
  "shoe_store",
  "shopping_mall",
  "spa",
  "stadium",
  "storage",
  "store",
  "subway_station",
  "synagogue",
  "taxi_stand",
  "train_station",
  "travel_agency",
  "university",
  "veterinary_care",
  "zoo"
];
/**
 * @depend PlaceTypes.js
 */

var InfoWindowHelpers = {
  getInfoWindowFor: function (result) {
    var typeLabels = '';

    for (var t = 0; t < result.types.length; t++)
    {
      typeLabels += '<li class="label">' + PlaceTypes.underscoredToHuman(result.types[t]) + '</li>';
    }

    var contentString = '<div class="result-info-content">'+
        '<h2 class="result-info-content-heading">' + result.name + '</h2>'+
        '<div class="result-info-content-body">'+
        '<ul class="result-types">' + typeLabels + '</ul>'+
        '</div>'+
        '</div>';

    var infoWindow = new google.maps.InfoWindow ({
      content: contentString
    });
    
    return infoWindow;
  }
}

/**
 * @depend DirectionsRouteHelpers.js
 * @depend LatLngExtensions.js
 * @depend MapExtensions.js
 * @depend NumberExtensions.js
 * @depend InfoWindowHelpers.js
 */

function Scroutenise(map) {
  var searchService = new google.maps.places.PlacesService(map),
    directionsService = new google.maps.DirectionsService(),
    directionsDisplay = new google.maps.DirectionsRenderer();

  directionsDisplay.setMap(map);
    
  return {
    map : map,

    searchService : searchService,

    directionsService : directionsService,

    directionsDisplay : directionsDisplay,

    debugMode : false,

    searchMethod : "RADIUS",

    renderedResultReferences : [],

    OnSearchStart : function (callback) {
      this.onSearchStart = callback;
    },

    OnSearchStep : function (callback) {
      this.onSearchStep = callback;
    },

    OnSearchEnd : function (callback) {
      this.onSearchEnd = callback;
    },

    addMarkerFromPlacesResult : function (result) {
      if(this.renderedResultReferences.indexOf(result.id) == -1)
      {
        var placeLatLng = new google.maps.LatLng(result.geometry.location.lat(), result.geometry.location.lng())
          ,marker = new google.maps.Marker({
            position: placeLatLng,
            title: result.name
          });

        this.map.addInfoWindow(InfoWindowHelpers.getInfoWindowFor(result), marker);
        this.map.addMarker(marker);

        this.renderedResultReferences.push(result.id);
      }
    },

    clearResults : function ()
    {
      this.map.clearMarkers();
      this.renderedResultReferences = [];
    },

    searchWithinBounds : function (searchTypes, bounds, callback)
    {        
      var searchRequest = {
        bounds: bounds,
        types: searchTypes
      };
      this.searchService.search(searchRequest, callback);
    },

    searchAroundPoint : function (latLngPoint, searchTypes, searchRadius, searchService, callback)
    {
      var searchRequest = {
        location: latLngPoint,
        radius: searchRadius,
        types: searchTypes
      };
      this.searchService.search(searchRequest, callback);
    },

    searchAroundPoint : function (latLngPoint, searchTypes, searchRadius, searchService, callback)
    {
      var searchRequest = {
        location: latLngPoint,
        radius: searchRadius,
        types: searchTypes
      };
      this.searchService.search(searchRequest, callback);
    },

    getDirections : function (start, end, typesToSearchFor, searchRadius, travelMode)
    {
      var self = this,
        directions = {
          origin: start,
          destination: end,
          provideRouteAlternatives: false,
          travelMode: travelMode,
          unitSystem: google.maps.UnitSystem.METRIC
        };

      this.map.clearMarkers();
      this.map.clearCircles();
      this.clearResults();

      if(typeof(this.onSearchStart) != 'undefined')
        this.onSearchStart();

      self.directionsService.route(directions, function(result, status) {
        if (status == google.maps.DirectionsStatus.OK) {
          self.directionsDisplay.setDirections(result);

          var allPoints = DirectionsRouteHelpers.getPathAsLatLngArray(result, searchRadius / 2);

          //// Search method: make one request using bounds and then trim it
          //// This method is slightly flawed because 20 is the maximum number of results
          //// Maybe split the bounds into x number of sections and search that way?
          //// Or a combo of both methods, instead of radius use bounds and then we can ensure
          //// That they join up
          if(self.searchMethod == "BOUNDS") {
            for(var i = 0; i < 5; i++) {
              var originalBounds = result.routes[0].bounds;
              var resultingBounds = originalBounds.expandBy(searchRadius);

              self.searchWithinBounds(typesToSearchFor, resultingBounds, function(results, searchStatus) {
                if (searchStatus == google.maps.places.PlacesServiceStatus.OK) {
                  if(this.debugMode == true) {
                    var rect = new google.maps.Rectangle();
                    rect.setBounds(resultingBounds);
                    rect.setMap(self.map);
                  }
                  for (var j = 0; j < results.length; j++) {
                    if(MapHelpers.withinRadiusOfAPoint(results[j], allPoints, searchRadius))
                      self.addMarkerFromPlacesResult(results[j]);
                  }
                }

                if (typeof(self.onSearchEnd) != 'undefined') {
                  self.onSearchEnd(results, searchStatus);
                }
              });
            }
          //// Search method by making loadsa requests
          } else if(self.searchMethod == "RADIUS") {
            var relevantResults = [],
              searchStatus;

            for(var i = 0; i < allPoints.length; i++)
            {
              self.searchAroundPoint(allPoints[i], typesToSearchFor, searchRadius, self.searchService, function(results, sStatus) {
                if (sStatus == google.maps.places.PlacesServiceStatus.OK) {
                  if (typeof searchStatus === 'undefined') {
                    // We only set if it's undefined because we want to return a non-200 if anything at all goes wrong down in the else
                    searchStatus = sStatus;
                  }

                  relevantResults = relevantResults.concat(results);

                  for (var j = 0; j < results.length; j++) {
                    self.addMarkerFromPlacesResult(results[j]);
                  }

                  if(typeof(self.onSearchStep) != 'undefined') {
                    self.onSearchStep(1, 1);
                  }
                } else {
                  searchStatus = sStatus;
                }
              });

              if(typeof(self.onSearchStep) != 'undefined')
                self.onSearchStep(i, allPoints.length);

              if(this.debugMode == true)
              {
                self.map.addCircle(new google.maps.Circle({
                  center: allPoints[i],
                  radius: searchRadius
                }));
              }

              if (i == (allPoints.length - 1) && typeof (self.onSearchEnd) != 'undefined') {
                self.onSearchEnd(relevantResults, searchStatus);
              }
            }
          }
        }
      });
    }
  };
}
